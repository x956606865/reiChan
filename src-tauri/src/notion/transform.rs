//! Transform executor for Notion import mappings.

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

use rquickjs::{CatchResultExt, Context as JsContext, CaughtError, Runtime, String as JsString};
use serde_json::{Map, Value};

const JS_TIMEOUT: Duration = Duration::from_millis(50);
const OUTPUT_LIMIT_BYTES: usize = 16 * 1024; // 16KB safety limit

pub struct TransformExecutor {
    runtime: Runtime,
}

impl TransformExecutor {
    pub fn new() -> Result<Self, TransformError> {
        let runtime = Runtime::new().map_err(|err| TransformError::Engine(err.to_string()))?;
        Ok(Self { runtime })
    }

    pub fn execute(&self, code: &str, value: Value, ctx: TransformContext) -> Result<Value, TransformError> {
        if code.trim().is_empty() {
            return Err(TransformError::Empty);
        }

        let context = JsContext::full(&self.runtime)
            .map_err(|err| TransformError::Engine(err.to_string()))?;

        let timeout_flag = Arc::new(AtomicBool::new(false));
        let flag = timeout_flag.clone();
        let start = Instant::now();
        self.runtime.set_interrupt_handler(Some(Box::new(move || {
            if start.elapsed() > JS_TIMEOUT {
                flag.store(true, Ordering::Relaxed);
                return true;
            }
            false
        })));

        let record_value = Value::Object(ctx.record.clone());
        let script = build_script(code, &value, &record_value, ctx.row_index);

        let eval_result: Result<String, String> = context.with(|js_ctx| {
            match js_ctx.eval::<JsString, _>(script.clone()).catch(&js_ctx) {
                Ok(out) => out.to_string().map_err(|err| err.to_string()),
                Err(err) => {
                    let message = match err {
                        CaughtError::Exception(ex) => ex
                            .message()
                            .unwrap_or_else(|| "Exception generated by QuickJS".to_string()),
                        CaughtError::Value(val) => val
                            .as_string()
                            .and_then(|s| s.to_string().ok())
                            .unwrap_or_else(|| "JavaScript threw non-error value".to_string()),
                        CaughtError::Error(e) => e.to_string(),
                    };
                    Err(message)
                }
            }
        });
        self.runtime.set_interrupt_handler(None);

        if timeout_flag.load(Ordering::Relaxed) {
            return Err(TransformError::Timeout);
        }

        let output = eval_result.map_err(TransformError::Execution)?;

        if output.len() > OUTPUT_LIMIT_BYTES {
            return Err(TransformError::OutputTooLarge(output.len()));
        }

        let parsed: Value = serde_json::from_str(&output)
            .map_err(|err| TransformError::Serialization(err.to_string()))?;
        let result = parsed
            .get("result")
            .cloned()
            .unwrap_or(Value::Null);
        Ok(result)
    }
}

fn build_script(code: &str, value: &Value, record: &Value, row_index: usize) -> String {
    let value_json = serde_json::to_string(value).unwrap_or_else(|_| "null".into());
    let record_json = serde_json::to_string(record).unwrap_or_else(|_| "{}".into());
    format!(
        r#"const __transform_value = {value_json};
const __transform_record = {record_json};
const __transform_utils = {{
    toNumber(value) {{
        if (value === null || value === undefined || value === '') return null;
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
    }},
    toDateISO(value) {{
        if (value === null || value === undefined || value === '') return null;
        const date = new Date(value);
        if (!Number.isFinite(date.getTime())) return null;
        return date.toISOString();
    }},
    trim(value) {{
        if (value === null || value === undefined) return '';
        return String(value).trim();
    }},
    slugify(value) {{
        if (value === null || value === undefined) return '';
        return String(value)
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
    }}
}};
const __transform_ctx = {{
    rowIndex: {row_index},
    record: __transform_record,
    utils: __transform_utils,
}};
const __transform_fn = (() => {{
    {code}
    if (typeof transform === 'function') return transform;
    if (typeof module !== 'undefined' && typeof module.exports === 'function') return module.exports;
    throw new Error('transform function must be defined');
}})();
const __transform_result = __transform_fn(__transform_value, __transform_ctx);
const __transform_normalized = __transform_result === undefined ? null : __transform_result;
JSON.stringify({{ result: __transform_normalized }});
"#,
        value_json = value_json,
        record_json = record_json,
        row_index = row_index,
        code = code
    )
}

#[derive(Debug, Clone)]
pub struct TransformContext {
    pub row_index: usize,
    pub record: Map<String, Value>,
}

#[derive(Debug, thiserror::Error)]
pub enum TransformError {
    #[error("transform code is empty")]
    Empty,
    #[error("transform timed out")]
    Timeout,
    #[error("transform output too large: {0} bytes")]
    OutputTooLarge(usize),
    #[error("transform serialization error: {0}")]
    Serialization(String),
    #[error("transform execution error: {0}")]
    Execution(String),
    #[error("transform engine error: {0}")]
    Engine(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_execute_returns_value() {
        let executor = TransformExecutor::new().expect("runtime");
        let ctx = TransformContext { row_index: 0, record: Map::new() };
        let result = executor
            .execute(
                "function transform(value) { return value; }",
                Value::String("hello".into()),
                ctx,
            )
            .expect("ok");
        assert_eq!(result, Value::String("hello".into()));
    }

    #[test]
    fn empty_code_rejected() {
        let executor = TransformExecutor::new().expect("runtime");
        let ctx = TransformContext { row_index: 0, record: Map::new() };
        let err = executor
            .execute("   ", Value::Null, ctx)
            .expect_err("should fail");
        assert!(matches!(err, TransformError::Empty));
    }
}
